# -*- coding: utf-8 -*-
"""[ kaggle study] Object detection RCNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JceuCdu1rz5xrgPef9H_wrSqK3XfyUA0
"""

# =================================================== [ setting ] ======================================================
import os 
import cv2 
import numpy as np 
import pandas as pd 
from sklearn.model_selection import train_test_split

import tensorflow as tf 
import matplotlib.pyplot as plt

from google.colab import drive 
drive.mount('/content/drive/')
os.chdir("/content/drive/MyDrive/study/[  Hongmungwan ]/Cmp. Project/Car Object Detection")

Data = pd.read_csv("./data/train_solution_bounding_boxes (1).csv")

# =================================================== [ preprocessing ] ======================================================
cv2.setUseOptimized(True)
ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()

def get_iou(bb1, bb2):
    assert bb1['x1'] < bb1['x2'] #bb1
    assert bb1['y1'] < bb1['y2']

    assert bb2['x1'] < bb2['x2'] #bb2
    assert bb2['y1'] < bb2['y2'];

    x_left = max(bb1['x1'], bb2['x1'])
    y_top = max(bb1['y1'], bb2['y1'])
    x_right = min(bb1['x2'], bb2['x2'])
    y_bottom = min(bb1['y2'], bb2['y2'])

    if x_right < x_left or y_bottom < y_top:
      return 0.0

    intersection_area = (x_right - x_left) * (y_bottom - y_top)
    bb1_area = (bb1['x2'] - bb1['x1']) * (bb1['y2'] - bb1['y1'])
    bb2_area = (bb2['x2'] - bb2['x1']) * (bb2['y2'] - bb2['y1'])
    iou = intersection_area / float(bb1_area + bb2_area - intersection_area)
    assert iou >= 0.0
    assert iou <= 1.0
    return iou

image_liste = []
k = 0
l = 0
z = 0 #Loading
for a in pd.read_csv('./data/train_solution_bounding_boxes (1).csv').values :
  Name, xmin, ymin, xmax, ymax = a
  bb1 = {'x1' : int(xmin), 'y1' : int(ymin), 'x2' : int(xmax), 'y2' : int(ymax) }
  try :
    img = cv2.imread('./data/training_images/'+ Name)
    ss.setBaseImage(img)
    ss.switchToSelectiveSearchFast()
    rects = ss.process()
    for i in rects:
      x, y, w, h = i # Selective bounty boxxes
      bb2 = {'x1' : x, 'y1' : y, 'x2' : x + w, 'y2' : y + h}
      img1 = img[bb2['y1'] : bb2['y2'], bb2['x1'] : bb2['x2']] # Crop img
      img1_shape = cv2.resize(img1, (224,224))
      if  k < l :
            if 0.5 < get_iou(bb1, bb2) :  
              image_liste.append([img1_shape,1])
              k += 1
      else :
        if 0.5 < get_iou(bb1, bb2) :  
          image_liste.append([img1_shape, 1])
          k += 1
        else :
          image_liste.append([img1_shape, 0])
          l += 1
  except Exception as e:
    print('hata var',e)
  z += 1
  print(Name, z, len(rects))

data = []
data_label = []
for features,label in image_liste:
  data.append(features)
  data_label.append(label)

data = np.asarray(data)
data_label = np.asarray(data_label) 
x_train, x_val, y_train, y_val = train_test_split(data, data_label, test_size = 0.3, random_state = 42)

# =================================================== [ modeling ] ======================================================
base_model = tf.keras.applications.VGG16(include_top = False,input_shape = (224,224,3), weights = 'imagenet')
model = tf.keras.Sequential()
model.add(base_model)
model.add(tf.keras.layers.GlobalAveragePooling2D())
model.add(tf.keras.layers.Dropout(0.5))
model.add(tf.keras.layers.Dense(1,activation = 'sigmoid'))

base_model.trainable = False
model.compile(loss='binary_crossentropy',optimizer=tf.keras.optimizers.Adam(),metrics = 'accuracy')
epoch = 4
hist = model.fit(x_train, y_train, epochs = epoch,validation_data = (x_val, y_val))

